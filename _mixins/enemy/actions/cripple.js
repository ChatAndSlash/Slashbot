"use strict";

const Random = require('@util/random');
const Text   = require('@util/text');

const PROPERTIES = require('@constants').PROPERTIES;

const FLAG_TURNS_CRIPPLED_ = 'turns_crippled_';

/**
 * Cripple the character, reducing offence or defence by 80/50% for 2-4 turns.
 *
 * @param {integer} actionWeight - The chance to perform this attack out of 100.
 * @param {integer} duration - The duration of the poison.
 * @param {string} text - The combat text to display on a successful poison attack.
 *
 * @return {Mixin}
 */
const CrippleAction = (actionWeight, {
  text = "Black tendrils of mist surround you, infusing your body and crippling your %s by %s for %d turns!"
} = {}) => {
  return (Enemy) => class extends Enemy {
    constructor(info) {
      super(info);

      this.fightActionProperties.cripple = [
        PROPERTIES.IS_ATTACK,
      ];
    }

    /**
     * Get the fight actions for this enemy.
     *
     * @param {Character} character - The character this enemy is fighting.
     * @param {object} actions - Actions passed in from mixed-in actions.
     *
     * @return {object}
     */
    getFightActions(character, actions = {}) {
      actions.cripple = actionWeight;

      return super.getFightActions(character, actions);
    }

    /**
     * Cripple the character, reducing offence or defence by 80/50% for 2-4 turns.
     *
     * @param {Character} character - The character to cripple.
     *
     * @return {array} Messages generated by this action.
     */
    cripple(character) {
      const stat = Random.getWeighted([
        { 'weight': 60, value: 'offence' },
        { 'weight': 40, value: 'defence' },
      ]);
      const amount = (stat === "defence") ? "50%" : "80%";
      const turns = Random.between(2, 4);

      this.setFlag(FLAG_TURNS_CRIPPLED_ + stat, turns + 1);

      return [__(text, __(Text.ucFirst(stat)), amount, turns)];
    }

    /**
     * Allow attack parameters to be modified before being used in an attack.
     *
     * @param {object} params - The parameters to modify.
     * @param {Combatant} defender - The defender of the attack.
     *
     * @return {object}
     */
    attackerModifyAttackParameters(params, defender) {
      if (this.hasFlag(FLAG_TURNS_CRIPPLED_ + 'defence')) {
        params.defence = Math.ceil(params.defence * 0.8);
      }

      return params;
    }

    /**
     * Allow attack parameters to be modified before being used in an attack.
     *
     * @param {object} params - The parameters to modify.
     * @param {Combatant} attacker - The attacker.
     *
     * @return {object}
     */
    defenderModifyAttackParameters(params, attacker) {
      if (this.hasFlag(FLAG_TURNS_CRIPPLED_ + 'offence')) {
        params.offence = Math.ceil(params.offence * 0.5);
      }

      return params;
    }

    /**
     * Perform any actions that happen after the round (decrement/clear all timers, etc)
     *
     * @param {Combatant} opponent - The current combatant's opponent.
     *
     * @return {array} Messages generated by these actions.
     */
    doPostRoundActions(opponent) {
      let messages = super.doPostRoundActions(opponent);

      const flagOffence = FLAG_TURNS_CRIPPLED_ + 'offence';
      this.decrementFlag(flagOffence);
      if (this.hasFlag(flagOffence)) {
        const turns = this.getFlag(flagOffence);
        messages.push(__("Your Offence is crippled for %d more turns.", turns));
      }

      const flagDefence = FLAG_TURNS_CRIPPLED_ + 'defence';
      this.decrementFlag(flagDefence);
      if (this.hasFlag(flagDefence)) {
        const turns = this.getFlag(flagDefence);
        messages.push(__("Your Defence is crippled for %d more turns.", turns));
      }

      return messages;
    }
  };
};

module.exports = {
  CrippleAction
};