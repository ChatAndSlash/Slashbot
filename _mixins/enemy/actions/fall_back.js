"use strict";

const { sprintf } = require("sprintf-js");
const { FLAGS, PROPERTIES } = require('@constants');

const FLAG_FALL_BACK_COOLDOWN = 'fall_back_cooldown';

/**
 * Do 50% damage and gain ranged flag.
 *
 * @param {integer} actionWeight - The chance to perform this attack out of 100.
 * @param {integer} cooldown - The number of turns that must pass before falling back again.
 * @param {float} multiplier - The amount to modify the attack by.
 * @param {boolean} cannotCrit - If this attack cannot crit.
 * @param {string} attackText - The text string to display when attacking.
 *
 * @return Mixin
 */
const FallBackAction = (actionWeight, {
  cooldown = 3,
  multiplier = 0.5,
  cannotCrit = true,
  attackText = "%s feints and manages to nick you for %s damage as they fall back and gain some distance."
} = {}) => {
  return (Enemy) => class extends Enemy {
    constructor(info) {
      super(info);

      this.fightActionProperties.fallBack = [
        PROPERTIES.IS_ATTACK,
      ];
    }

    /**
     * Get the fight actions for this enemy.
     *
     * @param {Character} character - The character this enemy is fighting.
     * @param {object} actions - Actions passed in from mixed-in actions.
     *
     * @return {object}
     */
    getFightActions(character, actions = {}) {
      // Don't fall back if already at range or cooling down
      if ( ! character.isAtRange(this) &&  ! this.hasFlag(FLAG_FALL_BACK_COOLDOWN)) {
        actions.fallBack = actionWeight;
      }

      return super.getFightActions(character, actions);
    }

    /**
     * Fall back to range.
     *
     * @param {Character} character - The character being attacked.
     *
     * @return {array}
     */
    fallBack(character) {
      this.setFlag(FLAGS.DAMAGE_MODIFIER, multiplier);

      if (cannotCrit) {
        this.setFlag(FLAGS.CANNOT_CRIT);
      }

      return this.attackHelper(character, (attackInfo) => {
        this.setFlag(FLAGS.IS_RANGED);

        const damageText = attackInfo.damage > 0 ? `*${attackInfo.damage}*` : "no";
        character.decreaseHp(attackInfo.damage);
        this.setFlag(FLAG_FALL_BACK_COOLDOWN, cooldown);

        return [sprintf(attackText, this.getDisplayName(character), damageText)];
      });
    }

    /**
     * Perform any actions that happen after the round (decrement/clear all timers, etc)
     *
     * @param {Combatant} opponent - The current combatant's opponent.
     *
     * @return {array} Messages generated by these actions.
     */
    doPostRoundActions(opponent) {
      const messages = super.doPostRoundActions(opponent);

      if (this.hasFlag(FLAG_FALL_BACK_COOLDOWN)) {
        this.decrementFlag(FLAG_FALL_BACK_COOLDOWN);
      }

      return messages;
    }
  };
};

module.exports = {
  FallBackAction
};