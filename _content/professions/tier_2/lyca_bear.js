"use strict";

const Combat            = require('@app/combat');
const LycaTransformBase = require('@content/professions/tier_2/lyca_transform_base');

const {
  PROFESSIONS,
  FLAGS,
  PROPERTIES,
} = require('@constants');

const SKILL_SLAM      = 'slam';
const STAMINA_SLAM    = 2;
const SLAM_MULTIPLIER = 1;
const SLAM_STUN_TURNS = 2;

const SKILL_BITE          = 'bite';
const STAMINA_BITE        = 2;
const FLAG_BITE_COOLDOWN  = 'bite_cooldown';
const BITE_MULTIPLIER     = 0.8;
const BITE_COOLDOWN_TURNS = 1;

const SKILL_MAUL      = 'MAUL';
const STAMINA_MAUL    = 6;
const MAUL_MULTIPLIER = 2.5;
const MAUL_STUN_TURNS = 2;

/**
 * Plural is "Lycae".
 */
class Lybear extends LycaTransformBase {
  constructor() {
    super({
      type: PROFESSIONS.LYCA,
      displayName: "Lybear",
      description: "",
      details: "",
      image: 'professions/lyca.png',
    });
  }

  /**
   * Get the offence stat for Lycae.
   *
   * When not transformed:
   * 0.4 Force + 0.4 Technique = 0.8
   *
   * When transformed:
   * - Wolf: 0.6 Force + 0.6 Technique = 1.2
   * - Bear: 1.2 Force = 1.2
   * - Lion: 1.2 Technique = 1.2
   * - Dragon: 0.6 Force + 0.6 Technique
   *
   * @param {Character} character - The character to get the offence stat for.
   *
   * @return {integer}
   */
  getOffence(character) {
    return character.force * 1.2;
  }

  /**
   * Do any actions that might happen after each round of combat (regen, etc.)
   *
   * @param {Character} character - The character in combat.
   *
   * @return {array} The messages generated by these actions.
   */
  doPostRoundActions(character) {
    character.decrementFlag(FLAG_BITE_COOLDOWN);

    return [];
  }

  /**
   * Clear bite cooldown flag after fight.
   *
   * @param {Character} character - The character who was in the fight.
   * @param {array} messages - The messages already generated in this fight.
   *
   * @return {array}
   */
  doFightEnd(character, messages) {
    character.clearFlag(FLAG_BITE_COOLDOWN);

    return messages;
  }

  /**
   * Get the skills the provided character has access to from this profession.
   *
   * NB: Can't call canDoSkill in here, as it will recurse indefinitely.
   *
   * @param {Character} character - The character getting the skills of this profession.
   * @param {boolean} addSupport - Add selected Support Skill.
   *
   * @return {object}
   */
  getSkills(character, addSupport = true) {
    let skills = {
      [SKILL_SLAM]: {
        name: "Slam",
        description: "Slam Tired enemies and stun them for two turns.",
        cost: STAMINA_SLAM,
        properties: [
          PROPERTIES.IS_ATTACK,
        ],
      },
      [SKILL_BITE]: {
        name: "Bite",
        description: "Bite enemies for double damage, and heal half of that damage back.",
        cost: STAMINA_BITE,
        properties: [
          PROPERTIES.IS_ATTACK,
        ],
      },
      [SKILL_MAUL]: {
        name: "Maul",
        description: "Deal heavy damage to enemies and stund them for two turns.",
        cost: STAMINA_MAUL,
        properties: [
          PROPERTIES.IS_ATTACK,
        ],
      },
    };

    if (addSupport) {
      skills = this.addSupportSkill(character, skills);
    }

    return skills;
  }

  /**
   * Lycae forms can always use their skills.
   *
   * @param {array} dbRow - The database row to extract the trained skills from.
   * @param {string} type - The type of profession being loaded.
   * @param {Character} character - The character loading the skills.
   *
   * @return {array}
   */
  getTrained(dbRow, type, character) {
    return {
      [SKILL_SLAM]: true,
      [SKILL_BITE]: true,
      [SKILL_MAUL]: true,
    };
  }

  /**
   * Check to see if a character can perform a specific combat skill.
   *
   * @param {Character} character - The character performing the skill.
   * @param {string} skill - The skill to perform.
   *
   * @return {array} Messages arising from the skill.
   */
  canDoSkill(character, skill) {
    if (SKILL_BITE === skill && character.hasFlag(FLAG_BITE_COOLDOWN)) {
      return false;
    }

    return super.canDoSkill(character, skill);
  }

  /**
   * Get the error message for why you can't use this skill.
   *
   * @param Character character The character performing the skill.
   * @param string    skill     The skill to perform.
   *
   * @return string
   */
  getSkillErrorMessage(character, skill) {
    if (SKILL_BITE === skill && character.hasFlag(FLAG_BITE_COOLDOWN)) {
      return ":warning: You're still chewing, and can't bite yet.";
    }

    return super.getSkillErrorMessage(character, skill);
  }

  /**
   * Perform a specific combat skill.
   *
   * @param {Character} character - The character performing the skill.
   * @param {string} type - The type of the skill to perform.
   *
   * @return {array} Messages arising from the skill.
   */
  doSkill(character, type) {
    if (SKILL_SLAM === type) {
      return this.doSkillSlam(character);
    }
    else if (SKILL_BITE === type) {
      return this.doSkillBite(character);
    }
    else if (SKILL_MAUL === type) {
      return this.doSkillMaul(character);
    }

    return super.doSkill(character, type);
  }

  /**
   * Damage & 2-turn stun after Tired.
   *
   * @param {Character} character - The character doing the biting.
   *
   * @return {array}
   */
  doSkillSlam(character) {
    const enemy = character.enemy;
    let messages = [];

    character.stamina -= STAMINA_SLAM;

    if (enemy.isTired()) {
      enemy.setFlag(FLAGS.STUNNED_TURNS, SLAM_STUN_TURNS + 1);
      messages = messages.concat(Combat.doAttack(character, {
        message: `:right_anger_bubble: You slam your opponent fiercely, dealing %s damage to %s and stunning them for ${SLAM_STUN_TURNS} turns!%s`,
        multiplier: SLAM_MULTIPLIER,
      }));
    }
    else {
      messages.push(`${enemy.getDisplayName(character)} isn't tired, and easily dodges your attempt to slam them.`);
    }

    return messages;
  }

  /**
   * BITE for 1x damage and leave a bleeding wound DoT for 2x damage.
   *
   * @param {Character} character - The character doing the biting.
   *
   * @return {array}
   */
  doSkillBite(character) {
    character.stamina -= STAMINA_BITE;
    character.setFlag(FLAG_BITE_COOLDOWN, BITE_COOLDOWN_TURNS + 1);

    const { damage, messages } = Combat.doAttack(character, {
      message: ":grimacing: You bite %2$s, dealing %1$s damage and tearing a chunk out of them!%3$s",
      multiplier: BITE_MULTIPLIER,
      returnDamage: true
    });

    const healed = character.increaseHp(Math.ceil(damage / 2));

    messages.push(`You chew noisily, healing ${healed} damage.`);

    return messages;
  }

  /**
   * Maul for 21.5x damage and stun for two.
   *
   * @param {Character} character - The character doing the biting.
   *
   * @return {array}
   */
  doSkillMaul(character) {
    character.stamina -= STAMINA_MAUL;
    character.enemy.setFlag(FLAGS.STUNNED_TURNS, MAUL_STUN_TURNS + 1);

    return Combat.doAttack(character, {
      message: `:right_anger_bubble: You maul %2$s for %1$s damage, your ferocity stunning them for ${MAUL_STUN_TURNS} turns!%3$s`,
      multiplier: MAUL_MULTIPLIER,
    });
  }
}

module.exports = Lybear;