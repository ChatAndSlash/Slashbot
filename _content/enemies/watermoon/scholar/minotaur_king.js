"use strict";

const mix                         = require('mixwith').mix;
const { WatermoonBonusBossEnemy } = require('@app/content/enemies/watermoon/bonus_boss');
const { WatermoonReputation }     = require('@mixins/enemy/reputation/watermoon');
const { BerserkAction }           = require('@mixins/enemy/actions/berserk');
const { ConcussAction }           = require('@mixins/enemy/actions/concuss');
const { DropsMoondrop }           = require('@mixins/enemy/loot/moondrop');

const { FLAGS } = require('@constants');

const FLAG_PREPARE_IMPALE = 'prepare_impale';
const FLAG_IS_ENRAGED     = 'enraged';
const FLAG_IMPALE_GLOAT   = 'impale_gloat';
const FLAG_ENRAGE_BONUS   = 'enrage_bonus';

const IMPALE_MULTIPLIER = 2;

class MinotaurKingEnemy extends mix(WatermoonBonusBossEnemy).with(
  BerserkAction(0),
  ConcussAction(0),
  DropsMoondrop(100, 20),
  WatermoonReputation(150)
) {
  constructor() {
    super({
      type: 'watermoon-scholar-minotaur_king',
      displayName: "Minotaur King",
      description: "And you thought a regular minotaur was imposing?  This kingly specimen of his kind stands as tall as the ceiling, has shoulders that seem to go on forever, and muscles on muscles on muscles.  He wears a small iron crown, a rare piece of adornment for minotaurs, and proof of his regal status.",
      fightActions: {
        // Enrage must be available in fight actions or it will fail the "can this action
        // be completed" test and be "rerolled", potentially leaving the enrage state
        // set, even though the action wasn't actually chosen
        enrage: 0,
      },
      stats: {
        base: {
          maxHp: 300,  // Increased HP - damage race!
        },
        perLevel: {
          maxHp: 300,  // Increased HP - damage race!
        }
      },
    });

    this.districtBosses = [
      'watermoon-scholar-gorvil',
      'watermoon-scholar-maze_master',
      'watermoon-scholar-minotaur_king',
    ];

    this.bossFlag = FLAGS.SCHOLAR_BOSS;
  }

  /**
   * Add 25% offence for every increase in enrage bonus.
   *
   * @return {integer}
   */
  getOffence() {
    const offence = super.getOffence();
    const multiplier = this.getFlag(FLAG_ENRAGE_BONUS, 0);

    return offence + (offence * multiplier / 4);
  }

  /**
   * Return the fight actions of this enemy as a weighted array for Random.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  getWeightedFightActions(character) {
    if (this.hasFlag(FLAG_PREPARE_IMPALE)) {
      return [{ value: 'impale', weight: 100 }];
    }
    else if (this.hasFlag(FLAG_IMPALE_GLOAT)) {
      return [{ value: 'gloat', weight: 100 }];
    }

    const actions = [
      { value: 'prepareImpale', weight: 20 },
      { value: 'getBerserk', weight: 20 },
      { value: 'concuss', weight: 20 },
    ];

    // Max of 6 enrage bonus
    const multiplier = this.getFlag(FLAG_ENRAGE_BONUS, 0);
    if (multiplier <= 6) {
      actions.push({ value: 'enrage', weight: 15 });
      actions.push({ value: 'doAttack', weight: 25 });
    }
    else {
      actions.push({ value: 'doAttack', weight: 40 });
    }

    return actions;
  }

  /**
   * Choose the fight action for this enemy.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {string}
   */
  chooseFightAction(character) {
    const action = super.chooseFightAction(character);

    if (action === 'enrage') {
      this.setFlag(FLAG_IS_ENRAGED);
    }

    return action;
  }

  /**
   * If enraged, take no damage.
   *
   * @param {object} attackInfo - The attack information.
   * @param {Combatant} attacker - The attacking combatant.
   *
   * @return {object}
   */
  doDefenderPostAttackProcessing(attackInfo, attacker) {
    if (this.hasFlag(FLAG_IS_ENRAGED)) {
      attackInfo.damage = 0;
      attackInfo.didCrit = false;
    }

    return attackInfo;
  }

  /**
   * Prepare to impale the player@
   *
   * @param {Combatant} opponent - The current combatant's opponent.
   *
   * @return {array} Messages generated by these actions.
   */
  prepareImpale(opponent) {
    this.setFlag(FLAG_PREPARE_IMPALE);

    return [`:right_anger_bubble: ${this.getDisplayName(opponent)} stomps the ground and roars at you!`];
  }

  /**
   * Impale a character that isn't defending!
   *
   * @param {Combatant} opponent - <<< This guy's about to get REKKED.
   *
   * @return {array} Messages generated by these actions.
   */
  impale(opponent) {
    this.clearFlag(FLAG_PREPARE_IMPALE);

    // Phew, defended.  Still take a bunch of damage, though
    if (opponent.hasFlag(FLAGS.IS_DEFENDING)) {

      // Cannot miss an impale
      this.setFlag(FLAGS.GUARANTEED_HIT_TURNS, 1);

      // Cannot crit an impale
      this.setFlag(FLAGS.IS_DISCIPLINED, 1);

      return this.attackHelper(opponent, (attackInfo) => {
        let messages = [];

        attackInfo.damage = Math.ceil(attackInfo.damage * IMPALE_MULTIPLIER);

        opponent.decreaseHp(attackInfo.damage);

        const damageText = attackInfo.damage > 0 ? `*${attackInfo.damage}*` : __('no');
        messages.push(`${this.getDisplayName(opponent)} imaples you, dealing ${damageText} damage!`);

        this.clearFlag(FLAGS.GUARANTEED_HIT_TURNS);
        this.clearFlag(FLAGS.IS_DISCIPLINED);

        return messages;
      });
    }
    // OH NO, IMPALED
    else {
      const damage = opponent.hp - 1;
      opponent.hp = 1;
      this.setFlag(FLAG_IMPALE_GLOAT);

      return [`:exploding_head: ${this.getDisplayName(opponent)} BRUTALLY impales you, dealing *${damage}* damage!  DAMN that hurt!`];
    }
  }

  /**
   * Gloat about impaling a character.
   *
   * @param {Combatant} opponent - <<< This guy's just got REKKED.
   *
   * @return {array} Messages generated by these actions.
   */
  gloat(opponent) {
    this.clearFlag(FLAG_IMPALE_GLOAT);

    return [`:laughing: ${this.getDisplayName(opponent)} bellows in triumph, gloating over his impending victory.`];
  }

  /**
   * Take 0 damage this turn, but gain 25% offence.
   *
   * @param {Combatant} opponent - The opponent in the combat.
   *
   * @return {array}
   */
  enrage(opponent) {
    this.incrementFlag(FLAG_ENRAGE_BONUS);

    return [`:angry: ${this.getDisplayName(opponent)} bellows with rage, ignoring all damage this turn and becoming more powerful!`];
  }

  /**
   * Perform any actions that happen after the round (decrement/clear all timers, etc)
   *
   * @param {Combatant} opponent - The current combatant's opponent.
   *
   * @return {array} Messages generated by these actions.
   */
  doPostRoundActions(opponent) {
    let messages = super.doPostRoundActions(opponent);

    this.clearFlag(FLAG_IS_ENRAGED);

    return messages;
  }

  /**
   * Clear all Scholar flags.
   *
   * @param {Character} character - The character who won the fight.
   * @param {array} messages - Any messages that have happened so far in combat.
   *
   * @return {array}
   */
  doFightSuccess(character, messages) {
    character.clearFlag(FLAGS.BOSS_DEFEATED_ + 'watermoon-scholar-minotaur');
    character.clearFlag(FLAGS.BOSS_DEFEATED_ + 'watermoon-scholar-gorgon');
    character.clearFlag(FLAGS.BOSS_DEFEATED_ + 'watermoon-scholar-empusa');
    character.clearFlag(FLAGS.HALLWAY_CHOICES);
    character.clearFlag(FLAGS.HALLWAY_REMAINING);
    character.clearFlag(FLAGS.HALLWAYS_COMPLETED);

    return super.doFightSuccess(character, messages);
  }

  /**
   * Do any extra actions required when running.
   *
   * @param {Character} character - The character doing the running.
   * @param {array} message - The previously-generated messages.
   *
   * @return {array}
   */
  doFightRun(character, messages) {
    messages = super.doFightRun(character, messages);

    this.leaveLabyrinth(character);
    messages.push(`The ${this.getDisplayName(character)} chases you right out of the Labyrinth!`);

    return messages;
  }

  /**
   * Special actions to take when this enemy has won.
   *
   * NOTE: Any additionally enqueued messages NEED a delay in order to ensure they show up after
   * the action fight message.
   *
   * @param {Character} character - The character who lost the fight.
   *
   * @return array
   */
  doFightFailure(character, messages) {
    messages = super.doFightFailure(character, messages);

    this.leaveLabyrinth(character);
    messages.push("As you pass into unconsciousness, you can feel your body being dragged out of the Labyrinth.");

    return messages;
  }
}

module.exports = MinotaurKingEnemy;