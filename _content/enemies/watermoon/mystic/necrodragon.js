"use strict";

const mix                 = require('mixwith').mix;
const Random              = require('@util/random');
const WatermoonEnemy      = require('@app/content/enemies/watermoon').WatermoonEnemy;
const WatermoonReputation = require('@mixins/enemy/reputation/watermoon').WatermoonReputation;
const FuriousAction       = require('@mixins/enemy/actions/furious').FuriousAction;
const CurseAction         = require('@mixins/enemy/actions/curse').CurseAction;
const DazeAction          = require('@mixins/enemy/actions/daze').DazeAction;
const BlindAction         = require('@mixins/enemy/actions/blind').BlindAction;
const DrainLifeAction     = require('@mixins/enemy/actions/drain_life').DrainLifeAction;
const CrippleAction       = require('@mixins/enemy/actions/cripple').CrippleAction;
const DropsMoondrop       = require('@mixins/enemy/loot/moondrop').DropsMoondrop;

const FlailAction = DazeAction(0, {
  dodgeText: ":dash: %s flails at you with her tail, but you dodge!",
  missText: "%s flails at you with her tail, but misses!",
  attackText: ":wavy_dash: %s flails at you with her tail, dealing %s damage %s dazing you for %d turns.%s"
});

const FLAGS = require('@constants').FLAGS;

const FLAG_FULL_HEALED = 'full_healed';
const FLAG_FIGHT_TURNS = 'fight_turns';
const FLAG_UNDEATH_TURNS = 'undeath_turns';

const SHADOW_HOWL_DPT = 1;

class NecrodragonEnemy extends mix(WatermoonEnemy).with(
  FuriousAction(0),
  CurseAction(0),
  FlailAction,
  BlindAction(0),
  DrainLifeAction(0),
  CrippleAction(0),
  DropsMoondrop(100, 6),
  WatermoonReputation(150)
) {
  constructor() {
    super({
      type: 'watermoon-mystic-necrodragon',
      displayName: 'Necrodragon',
      description: "A massive, bone-white dragon towers over you, staring down at you with flaming violet eyes.  Her wings are folded neatly behind her, and her long, ebony claws furrow the very stone beneath her as she approaches.",
      isBoss: true,
      scales: 8,
      stats: {
        base: {
          maxHp: 75,
          goldMin: 50,
          goldMax: 50
        },
        perLevel: {
          maxHp: 60,
          goldMin: 20,
          goldMax: 25
        }
      },
    });
  }

  /**
   * Set this enemy to a specific level.
   *
   * @param {integer} level - The level to set them to.
   * @param {integer} levelBonus - A location-based level bonus to add/subtract.
   */
  setLevel(level, levelBonus = 0) {
    super.setLevel(level, levelBonus);

    // Threshholds for summoning enemies
    this.threeQuartersHealth = Math.ceil(this.maxHp * 0.75);
    this.halfHealth          = Math.ceil(this.maxHp * 0.5);
    this.oneQuarterHealth    = Math.ceil(this.maxHp * 0.25);
  }

  /**
   * Get the fight actions for this enemy.
   *
   * @param {Character} character - The character this enemy is fighting.
   * @param {object} actions - Actions passed in from mixed-in actions.
   *
   * @return {object}
   */
  getFightActions(character, actions = {}) {
    // Fourth form?
    if (character.hasFlag(FLAGS.NECRODRAGON_DEFEATS, 3)) {
      if ( ! this.hasFlag(FLAG_FULL_HEALED)) {
        actions['fullHeal'] = 100;
      }
      else {
        actions['getFurious']  = 15;
        actions['drainLife']   = 10;
        actions['curseAttack'] = 5;
        actions['daze']        = 10;
        actions['blind']       = 5;
        actions['cripple']     = 5;
      }
    }
    // Third form?
    else if (character.hasFlag(FLAGS.NECRODRAGON_DEFEATS, 2)) {
      actions['getFurious']  = 20;
      actions['drainLife']   = 10;
      actions['curseAttack'] = 10;
      actions['daze']        = 10;
      actions['blind']       = 10;
    }
    // Second form?
    else if (character.hasFlag(FLAGS.NECRODRAGON_DEFEATS, 1)) {
      actions['getFurious']  = 20;
      actions['drainLife']   = 10;
      actions['curseAttack'] = 10;
      actions['daze']        = 10;
    }
    // First encounter?
    else {
      actions['getFurious']  = 20;
      actions['drainLife']   = 10;
      actions['curseAttack'] = 10;
    }

    return actions;
  }

  /**
   * At certain levels of health, boss is replaced with Guardian enemies.
   *
   * @param {Character} character - The attacking character.
   *
   * @return {array} Messages generated by these actions.
   */
  doPostRoundActions(character) {
    let messages = super.doPostRoundActions(character);

    if ( ! character.hasKilledEnemy('watermoon-mystic-cult_guardian') && this.hp <= this.threeQuartersHealth) {
      messages.push(this.summonGuardian(character, 'watermoon-mystic-cult_guardian', '"It\'sss not even worth fighting you myssself," she bellows.  "Guardian!  Deal with this pipsssqeak!"'));
      character.setFlag(FLAGS.NECRODRAGON_DEFEATS, 1);
    }
    else if ( ! character.hasKilledEnemy('watermoon-mystic-blackpool_guardian') && this.hp <= this.halfHealth) {
      messages.push(this.summonGuardian(character, 'watermoon-mystic-blackpool_guardian', '"If you insssissst on pursssuing this fight, it will only be to your death!  Face the Guardian of the Blackpool, and die!"'));
      character.setFlag(FLAGS.NECRODRAGON_DEFEATS, 2);
    }
    else if ( ! character.hasKilledEnemy('watermoon-mystic-zombie_guardian') && this.hp <= this.oneQuarterHealth) {
      messages.push(this.summonGuardian(character, 'watermoon-mystic-zombie_guardian', '"Why?  Why won\'t you die?  Why do you keep presssing onward againssst horrorsss that sssane people would balk at?  You think you\'re ssstrong?  Fine, face the ultimate Guardian, the unkillable undead, my Zombie Guardian!"'));
      character.setFlag(FLAGS.NECRODRAGON_DEFEATS, 3);
    }
    // Necrodragon is in undeath state, cannot be killed
    else if (character.hasFlag(FLAGS.NECRODRAGON_DEFEATS, 3) && this.hp <= 0) {
      const undeathTurns = this.getFlag(FLAG_UNDEATH_TURNS, 0);
      if (undeathTurns === 0) {
        messages.push(__("The Necrodragon roars at you.  \"Foolisssh whelp!  You cannot kill me!  I am already dead!\""));
      }
      else if (undeathTurns === 1) {
        messages.push(__('The Necrodragon\'s body begins to visibly decay.  "What isss thisss?" she hollers.  "What are you doing to me?"'));
      }
      else if (undeathTurns === 2) {
        messages.push(__('You can see flesh sloughing off the Necrodragon now.  "No!" she howls.  "I cannot be beaten!"'));
      }
      else if (undeathTurns === 3) {
        messages.push(__('The Necrodragon\'s body is nearly completely decayed.  You judge she can last only one more turn.  She is screaming incoherently now.'));
      }
      else if (undeathTurns === 4) {
        messages.push(__('With a gasp of air like a long, drawn-out sigh, the Necrodragon\'s body collapses in on itself, utterly consumed with rot and decay.'));
      }

      this.setFlag(FLAG_UNDEATH_TURNS, undeathTurns + 1);
    }
    // In fourth form but not undeath?  Get stronger every turn!
    else if (character.hasFlag(FLAGS.NECRODRAGON_DEFEATS, 3)) {
      const turns = this.getFlag(FLAG_FIGHT_TURNS, 0);
      this.setFlag(FLAG_FIGHT_TURNS, turns + 1);
      messages.push(__("The Necrodragon howls, and shadows grow deeper around her as she grows stronger!"));
    }

    return messages;
  }

  /**
   * Summon a guardian to replace the Necrodragon. After they die, bring back the Necrodragon.
   *
   * @param {Character} character - The opposing character.
   * @param {string} type - The type of guardian to summon.
   * @param {string} dragonText - Text for the Necrodragon to say as she withdraws.
   *
   * @return {array} Messages generated by these actions.
   */
  summonGuardian(character, type, dragonText) {
    const Enemies = require('@app/content/enemies').Enemies;
    let guardian = Enemies.new(type);
    guardian.setLevel(this.level);
    guardian.hp = guardian.maxHp;
    character.setFlag(FLAGS.NECRODRAGON_HEALTH, this.hp);

    character.enemy = guardian;

    return __(":fearful: The Necrodragon roars and falls back, allowing a %s to step in front and engage you.\n\n%s", guardian.getDisplayName(character), dragonText);
  }

  /**
   * Fully heal and gloat a bit, but only once...
   *
   * @param {Character} character - The opposing character.
   *
   * @return {array} Messages generated by this action.
   */
  fullHeal(character) {
    this.hp = this.maxHp;
    this.setFlag(FLAG_FULL_HEALED);

    return [
      __("The Necrodragon's wounds close before your very eyes.  She has fully healed!"),
      __('Delighting in the shock on your face, she laughs.  "Ha!  Did you think it would be thisss easy?  Witnesss my true power, insssect!"')
    ];
  }

  /**
   * Increase attack damage every turn.
   *
   * @param {object} attackInfo - The attack information.
   * @param {Combatant} defender - The defending combatant.
   *
   * @return {object}
   */
  doAttackerPostAttackProcessing(attackInfo, defender) {
    if (attackInfo.damage > 0) {
      const turns = this.getFlag(FLAG_FIGHT_TURNS, 0);
      attackInfo.damage += SHADOW_HOWL_DPT * turns;
    }

    return attackInfo;
  }

  /**
   * On fourth stage, stays alive for 5 turns, regardless of HP.
   *
   * @return boolean
   */
  isDead() {
    // If we're tracking fight turns, we're on the final form
    if (this.hasFlag(FLAG_FIGHT_TURNS)) {
      const undeathTurns = this.getFlag(FLAG_UNDEATH_TURNS, 0);
      if (undeathTurns > 0 || this.hp <= 0) {
        return undeathTurns === 5;
      }
    }

    return super.isDead();
  }

  /**
   * Increase this combatant's HP by a certain amount.
   * CAN'T INCREASE HP WHEN IN UNDEATH STATE.
   *
   * @param {integer} increaseBy The amount of HP to increase by.
   *
   * @return {integer} The difference in HP.
   */
  increaseHp(increaseBy) {
    if (this.hasFlag(FLAG_UNDEATH_TURNS)) {
      return 0;
    }

    return super.increaseHp(increaseBy);
  }

  /**
   * Special actions to take when this enemy has been beaten.
   *
   * NOTE: Any additionally enqueued messages NEED a delay in order to ensure they show up after
   * the action fight message.
   *
   * @param {Character} character - The character who won the fight.
   * @param {array} messages - Any messages that have happened so far in combat.
   *
   * @return {array}
   */
  doFightSuccess(character, messages) {
    // Gotta define this in here to avoid circular content file references
    const Locations = require('@app/content/locations').Locations;
    character.location = Locations.new('watermoon-gilded-exchange');

    character.clearFlag(FLAGS.NECRODRAGON_DEFEATS);
    character.clearFlag(FLAGS.NECRODRAGON_HEALTH);
    character.clearFlag(FLAGS.CATACOMBS_OPEN);
    character.clearFlag(FLAGS.FAITH_PORTAL_OPEN);
    character.clearFlag(FLAGS.SHADOW_PORTAL_OPEN);
    character.clearFlag(FLAGS.DEATH_PORTAL_OPEN);
    character.clearFlag(FLAGS.FAITH_BOSS_DEFEATED);
    character.clearFlag(FLAGS.SHADOW_BOSS_DEFEATED);
    character.clearFlag(FLAGS.DEATH_BOSS_DEFEATED);

    character.setFlag(FLAGS.IN_CUTSCENE);
    character.setFlag(FLAGS.MYSTIC_BOSS, Random.fromArray([
      'watermoon-mystic-lich_queen',
      'watermoon-mystic-skeleton_army',
      'watermoon-mystic-undying_slime',
    ]));

    character.track('Necrodragon Killed');

    messages = messages.concat([
      __("You approach the Necrodragon, intent on evoking Phaera's flame and consuming it, but before you can, it disappears in a bright golden flash, leaving only ash and dust behind."),
      __("You explore the rest of the Catacombs thoroughly, but finding nothing, return back to the Exchange and confront Aureth.  She smiles like the cat that's caught the canary."),
      { npc: 'aureth', text: __('"Good job, kid!  You\'ve got the look of a winner right now.  A winner who just killed a gross, smelly Necrodragon, am I right?"') },
      __("You nod your assent and Aureth laughs."),
      { npc: 'aureth', text: __('"I figured as much.  I tell ya, I feel stronger than I remember having felt since those three _parasites_ showed up in my town."') },
      { npc: 'aureth', text: __('"And that\'s all she wrote!  That\'s all the competition - uh I mean, vile nasty mean enemy dragons dealt with, yaaaay!"') },
      __("She pauses, trying to asses your reaction to her slip."),
      { npc: 'aureth', text: __('"Look, I know you originally came here to kill me, right?  And you\'re _probably_ looking to make good on that intention.  But let\'s examine your motivations a bit, okay?"') },
      { npc: 'aureth', text: __('"Birdmom, Phaera, yeah, she doesn\'t like dragons, sure.  We\'ve got a bad rep, and there are enough of us that revel in that reputation.  And honestly?  Yeah, they gotta go.  They wreck towns, they kill people, they\'re just bad for property values in general."') },
      { npc: 'aureth', text: __('"But some of us aren\'t that bad.  Look, I\'m not asking you to just take me at my word, but you know, _evaluate_ things a bit maybe?"') },
      { npc: 'aureth', text: __('"I\'ve done you right through all of this, and there\'s a semi-prospering town here I\'ve helped nurture.  In fact, why don\'t you go and ask around?  See if anyone has even one bad word to say about me."') },
      { npc: 'aureth', text: __('"Go and ask all three Guild Leaders if I\'m a bad person, and then come back here and tell me you still think we gotta have it out."') },
      __("You decide to take her advice and leave to seek out the Guild Leaders to get their perspective."),
    ]);

    character.slashbot.tellStory(messages, character);

    return [];
  }
}

module.exports = NecrodragonEnemy;