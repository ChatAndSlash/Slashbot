"use strict";

const mix                         = require('mixwith').mix;
const { fromArray, between }      = require('@util/random');
const { WatermoonBonusBossEnemy } = require('@app/content/enemies/watermoon/bonus_boss');
const { WatermoonReputation }     = require('@mixins/enemy/reputation/watermoon');
const { DropsMoondrop }           = require('@mixins/enemy/loot/moondrop');

const { FLAGS, PROPERTIES } = require('@constants');

const FLAG_DELAY_TURNS = 'delay_turns';

const DELAY_REDUCTION = 0.5;

const FLAG_LIGHTNING_SWEEP = 'lightning_sweep';
const DELAY_TURNS_LIGHTNING_SWEEP = 1; // 2, including windup turn
const MIN_LIGHTNING_SWEEP_ATTACKS = 1;
const MAX_LIGHTNING_SWEEP_ATTACKS = 3;

const FLAG_GRAB = 'grab';
const DELAY_TURNS_GRAB = 2; // 3, including windup turn
const FLAG_CHOKE_TURNS = 'choke_turns';
const TURNS_CHOKE = 2;
const MULTIPLIER_CHOKE = 2;

const FLAG_GROUND_POUND = 'ground_pound';
const DELAY_TURNS_GROUND_POUND = 3; // 4, including windup turn
const MULTIPLIER_GROUND_POUND = 4;
const STUN_TURNS_GROUND_POUND = 2;

const FLAG_POWER_SLAM = 'power_slam';
const DELAY_TURNS_POWER_SLAM = 4; // 5, including windup turn
const MULTIPLIER_POWER_SLAM = 5;

const MULTIPLIER_HAMMER_TOSS = 3;

class TheOxEnemy extends mix(WatermoonBonusBossEnemy).with(
  DropsMoondrop(100, 20),
  WatermoonReputation(150)
) {
  constructor() {
    super({
      type: 'watermoon-rumble-the_ox',
      displayName: "The Ox",
      description: "This massive, burly man holds a massive onyx sledgehammer.  It pulses with a slight red glow, and you recall tales of an enchanted hammer, one that took incredible will to wield, but that never, ever missed.",
      stats: {
        base: {
          maxHp: 55,  // Increased HP because of so many delay turns
        },
        perLevel: {
          maxHp: 195,  // Increased HP because of so many delay turns
        }
      },
    });

    this.districtBosses = [
      'watermoon-rumble-the_one',
      'watermoon-rumble-crane_and_dragon',
      'watermoon-rumble-the_ox',
    ];

    this.fightActionProperties.hammerToss = [
      PROPERTIES.IS_ATTACK,
      PROPERTIES.RANGED_ATTACK,
    ];

    this.bossFlag = FLAGS.RUMBLE_BOSS;
  }

  /**
   * No determiner, is just "The Ox".
   *
   * @param {Character} character - The character examining this enemy.
   *
   * @return {string}
   */
  getDeterminer(character) {
    return "";
  }

  /**
   * What to display after "You encountered " when starting a fight.
   *
   * @param {Character} character - The character encountering the enemy.
   *
   * @return {string}
   */
  getEncounterName(character) {
    return this.getLevelName(character);
  }

  /**
   * If The Ox is delaying, take less damage.
   *
   * @param {object} attackInfo - The attack information.
   * @param {Combatant} attacker - The attacking combatant.
   *
   * @return {object}
   */
  doDefenderPostAttackProcessing(attackInfo, attacker) {
    if (this.hasFlag(FLAG_DELAY_TURNS)) {
      attackInfo.damage = Math.ceil(attackInfo.damage * DELAY_REDUCTION);
    }

    return super.doDefenderPostAttackProcessing(attackInfo, this, attacker);
  }

  /**
   * Perform any actions that happen after the round (decrement/clear all timers, etc)
   *
   * @param {Combatant} opponent - The current combatant's opponent.
   *
   * @return {array} Messages generated by these actions.
   */
  doPostRoundActions(opponent) {
    let messages = super.doPostRoundActions(opponent);

    this.decrementFlag(FLAG_CHOKE_TURNS);

    return messages;
  }

  /**
   * Return the fight actions of this enemy as a weighted array for Random.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  getWeightedFightActions(character) {
    if (this.isAtRange(character)) {
      return [{ value: 'hammerToss', weight: 100 }];
    }
    else if (this.hasFlag(FLAG_DELAY_TURNS)) {
      return [{ value: 'delay', weight: 100 }];
    }
    else if (this.hasFlag(FLAG_GROUND_POUND)) {
      return [{ value: 'groundPound', weight: 100 }];
    }
    else if (this.hasFlag(FLAG_LIGHTNING_SWEEP)) {
      return [{ value: 'lightningSweep', weight: 100 }];
    }
    else if (this.hasFlag(FLAG_GRAB)) {
      return [{ value: 'grab', weight: 100 }];
    }
    else if (this.hasFlag(FLAG_CHOKE_TURNS)) {
      return [{ value: 'choke', weight: 100 }];
    }
    else if (this.hasFlag(FLAG_POWER_SLAM)) {
      return [{ value: 'powerSlam', weight: 100 }];
    }
    else {
      return [
        { value: 'windupGroundPound', weight: 25 },
        { value: 'windupLightningSweep', weight: 25 },
        { value: 'windupGrab', weight: 25 },
        { value: 'windupPowerSlam', weight: 25 },
      ];
    }
  }

  /**
   * Delay for a turn.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  delay(character) {
    this.decrementFlag(FLAG_DELAY_TURNS);

    return [fromArray([
      `${this.getDisplayName(character)} pauses, looking you dead in the eyes.  He is defending against attack.`,
      `${this.getDisplayName(character)} waits for you to make your move.  He is defending against attack.`,
      `${this.getDisplayName(character)} is biding his time.  He is defending against attack.`,
      `${this.getDisplayName(character)} is sitting tight.  He is defending against attack.`,
    ])];
  }

  /**
   * Winds up for a Lightning Sweep.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  windupLightningSweep(character) {
    this.setFlag(FLAG_LIGHTNING_SWEEP);
    this.setFlag(FLAG_DELAY_TURNS, DELAY_TURNS_LIGHTNING_SWEEP);

    return [`${this.getDisplayName(character)} lets his sledgehammer fall to the floor and drags it behind him.`];
  }

  /**
   * Sweeps hammer in a circle 1-3 times, crackling with lightning energy.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  lightningSweep(character) {
    this.clearFlag(FLAG_LIGHTNING_SWEEP);
    this.setFlag(FLAGS.CANNOT_CRIT);
    this.setFlag(FLAGS.CANNOT_MISS);
    character.setFlag(FLAGS.CANNOT_DODGE);

    return this.attackHelper(character, (attackInfo) => {
      let messages = [];

      this.clearFlag(FLAGS.CANNOT_CRIT);
      this.clearFlag(FLAGS.CANNOT_MISS);
      character.clearFlag(FLAGS.CANNOT_DODGE);

      const attacks = between(MIN_LIGHTNING_SWEEP_ATTACKS, MAX_LIGHTNING_SWEEP_ATTACKS);

      attackInfo.damage = Math.ceil(attackInfo.damage * attacks);
      character.decreaseHp(attackInfo.damage);

      const damageText = attackInfo.damage > 0 ? `*${attackInfo.damage}*` : __('no');
      messages.push(`:zap: ${this.getDisplayName(character)} spins his sledgehammer around himself in circle, hitting you ${attacks} times and dealing ${damageText} damage.`);

      return messages;
    });
  }

  /**
   * Winds up for a Ground Pound.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  windupGroundPound(character) {
    this.setFlag(FLAG_GROUND_POUND);
    this.setFlag(FLAG_DELAY_TURNS, DELAY_TURNS_GROUND_POUND);

    return [`${this.getDisplayName(character)} hefts his sledgehammer up on his shoulder.  The ground rumbles slightly.`];
  }

  /**
   * Pound you into the ground.  x4 damage and 2 turn stun.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  groundPound(character) {
    this.clearFlag(FLAG_GROUND_POUND);
    this.setFlag(FLAGS.CANNOT_CRIT);
    this.setFlag(FLAGS.CANNOT_MISS);
    character.setFlag(FLAGS.CANNOT_DODGE);

    return this.attackHelper(character, (attackInfo) => {
      let messages = [];

      this.clearFlag(FLAGS.CANNOT_CRIT);
      this.clearFlag(FLAGS.CANNOT_MISS);
      character.clearFlag(FLAGS.CANNOT_DODGE);

      attackInfo.damage = Math.ceil(attackInfo.damage * MULTIPLIER_GROUND_POUND);
      character.decreaseHp(attackInfo.damage);

      character.setFlag(FLAGS.STUNNED_TURNS, STUN_TURNS_GROUND_POUND + 1);

      const damageText = attackInfo.damage > 0 ? `*${attackInfo.damage}*` : __('no');
      messages.push(`:exploding_head: ${this.getDisplayName(character)} slams his sledgehammer into the ground in front of you.  The shockwave knocks you over, dealing ${damageText} damage and stunning you for ${STUN_TURNS_GROUND_POUND} turns.`);

      return messages;
    });
  }

  /**
   * Winds up for a Grab.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  windupGrab(character) {
    this.setFlag(FLAG_GRAB);
    this.setFlag(FLAG_DELAY_TURNS, DELAY_TURNS_GRAB);

    return [`${this.getDisplayName(character)} grips his sledgehammer tightly in two hands.`];
  }

  /**
   * Grabs you!  Stuns for 2x turns and does damage.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  grab(character) {
    this.clearFlag(FLAG_GRAB);
    this.setFlag(FLAG_CHOKE_TURNS, TURNS_CHOKE + 1);
    character.setFlag(FLAGS.STUNNED_TURNS, TURNS_CHOKE + 1);

    return [`:open_mouth: It was a feint! ${this.getDisplayName(character)} grabs you and starts choking you!`];
  }

  /**
   * Choke the character!
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  choke(character) {
    this.setFlag(FLAGS.CANNOT_CRIT);
    this.setFlag(FLAGS.CANNOT_MISS);
    character.setFlag(FLAGS.CANNOT_DODGE);

    return this.attackHelper(character, (attackInfo) => {
      let messages = [];

      this.clearFlag(FLAGS.CANNOT_CRIT);
      this.clearFlag(FLAGS.CANNOT_MISS);
      character.clearFlag(FLAGS.CANNOT_DODGE);

      attackInfo.damage = Math.ceil(attackInfo.damage * MULTIPLIER_CHOKE);
      character.decreaseHp(attackInfo.damage);

      const damageText = attackInfo.damage > 0 ? `*${attackInfo.damage}*` : __('no');
      messages.push(`:dizzy_face: ${this.getDisplayName(character)} chokes you!  You can't breathe and are dealt ${damageText} damage!`);

      if (1 === this.getFlag(FLAG_CHOKE_TURNS)) {
        messages.push("You struggle and manage to break free!");
      }

      return messages;
    });
  }

  /**
   * Winds up for a Power Slam.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  windupPowerSlam(character) {
    this.setFlag(FLAG_POWER_SLAM);
    this.setFlag(FLAG_DELAY_TURNS, DELAY_TURNS_POWER_SLAM);

    return [`${this.getDisplayName(character)} lets his sledgehammer fall nonchalantly to his side.`];
  }

  /**
   * Perform a power slam, knocking the character to range.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  powerSlam(character) {
    this.clearFlag(FLAG_POWER_SLAM);
    this.setFlag(FLAGS.CANNOT_CRIT);
    this.setFlag(FLAGS.CANNOT_MISS);
    character.setFlag(FLAGS.CANNOT_DODGE);

    return this.attackHelper(character, (attackInfo) => {
      let messages = [];

      this.clearFlag(FLAGS.CANNOT_CRIT);
      this.clearFlag(FLAGS.CANNOT_MISS);
      character.clearFlag(FLAGS.CANNOT_DODGE);

      attackInfo.damage = Math.ceil(attackInfo.damage * MULTIPLIER_POWER_SLAM);
      character.decreaseHp(attackInfo.damage);

      const damageText = attackInfo.damage > 0 ? `*${attackInfo.damage}*` : __('no');
      messages.push(`:scream: ${this.getDisplayName(character)} hauls off and slams you directly in your chest, dealing ${damageText} damage and knocking you back to range!`);

      character.setFlag(FLAGS.IS_RANGED);

      return messages;
    });
  }

  /**
   * Toss hammer at character and charge in to pick it up.
   *
   * @param {Character} character - The character this enemy is fighting.
   *
   * @return {array}
   */
  hammerToss(character) {
    this.setFlag(FLAGS.CANNOT_CRIT);
    this.setFlag(FLAGS.CANNOT_MISS);
    character.setFlag(FLAGS.CANNOT_DODGE);

    return this.attackHelper(character, (attackInfo) => {
      let messages = [];

      this.clearFlag(FLAGS.CANNOT_CRIT);
      this.clearFlag(FLAGS.CANNOT_MISS);
      character.clearFlag(FLAGS.CANNOT_DODGE);

      attackInfo.damage = Math.ceil(attackInfo.damage * MULTIPLIER_HAMMER_TOSS);
      character.decreaseHp(attackInfo.damage);

      const damageText = attackInfo.damage > 0 ? `*${attackInfo.damage}*` : __('no');
      messages.push(`:hammer: ${this.getDisplayName(character)} hurls his sledgehammer at you, dealing ${damageText} and knocking the wind out of you while he closes the distance!`);

      character.clearFlag(FLAGS.IS_RANGED);
      this.clearFlag(FLAGS.IS_RANGED);

      return messages;
    });
  }

  /**
   * Clear all Rumble flags.
   *
   * @param {Character} character - The character who won the fight.
   * @param {array} messages - Any messages that have happened so far in combat.
   *
   * @return {array}
   */
  doFightSuccess(character, messages) {
    character.clearFlag(FLAGS.NUM_FIGHTS);
    character.clearFlag(FLAGS.HENCHMEN_DEFEATED);

    character.clearFlag(FLAGS.BOSS_DEFEATED_ + 'watermoon-rumble-shadow_lesser');
    character.clearFlag(FLAGS.BOSS_DEFEATED_ + 'watermoon-rumble-drunken_master');
    character.clearFlag(FLAGS.BOSS_DEFEATED_ + 'watermoon-rumble-jackie_mann');
    character.clearFlag(FLAGS.BOSS_DEFEATED_ + 'watermoon-rumble-shadow_greater');

    return super.doFightSuccess(character, messages);
  }
}

module.exports = TheOxEnemy;