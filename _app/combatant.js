"use strict";

const Spells = require('@app/content/spells').Spells;
const Random = require('@util/random');

const FLAGS                     = require('@constants').FLAGS;
const ROUND_TIMED_STATUSES      = require('@constants').ROUND_TIMED_STATUSES;
const SINGLE_TURN_STATUSES      = require('@constants').SINGLE_TURN_STATUSES;
const STATS                     = require('@constants').STATS;
const PROPERTIES                = require('@constants').PROPERTIES;
const AOE_BONUS                 = require('@constants').AOE_BONUS;
const DEFAULT_BURNED_TURNS      = require('@constants').DEFAULT_BURNED_TURNS;
const BURN_BONUS                = require('@constants').BURN_BONUS;
const DEFAULT_CHILLED_TURNS     = require('@constants').DEFAULT_CHILLED_TURNS;
const CHILL_REDUCTION           = require('@constants').CHILL_REDUCTION;
const HIDDEN_DAGGERS_CRIT_BONUS = require('@constants').HIDDEN_DAGGERS_CRIT_BONUS;
const ACID_BLIND_CHANCE         = require('@constants').ACID_BLIND_CHANCE;
const CURSED_CHEST_MISS_CHANCE  = require('@constants').CURSED_CHEST_MISS_CHANCE;

/**
 * Base class for characters and enemies.
 */
class Combatant {
  constructor(info) {
    // Misc flags set by flag functions
    this._flags = {};

    this.properties = _.get(info, 'properties', []);
  }

  /**
   * Set HP this combatant has.
   *
   * @param {integer} hp The HP this combatant has.
   */
  set hp(hp) {
    this._hp = hp;
  }

  /**
   * Get the HP this combatant has.
   *
   * @return {integer}
   */
  get hp() {
    return this._hp;
  }

  /**
   * Idenfity if this character is dead (typically if HP <= 0).
   *
   * @return boolean
   */
  isDead() {
    return this.hp <= 0;
  }

  /**
   * Reduce this combatant's HP by a certain amount.
   *
   * @param {integer} reduceBy The amount of HP to reduce by.
   *
   * @return {integer} The difference in HP.
   */
  decreaseHp(reduceBy) {
    // Whole integer, at least one
    reduceBy = Math.ceil(reduceBy);

    const originalHp = this._hp;
    this._hp = Math.max(0, this._hp - reduceBy);

    // Character doing damage to enemy
    if (_.isUndefined(this.character)) {
      this.increaseStat(STATS.DAMAGE_RECEIVED, reduceBy);

      if (reduceBy > this.getStat(STATS.HIGHEST_DAMAGE_RECEIVED)) {
        this.setStat(STATS.HIGHEST_DAMAGE_RECEIVED, reduceBy);
      }

    }
    // Enemy doing damage to character
    else {
      this.character.increaseStat(STATS.DAMAGE_DONE, reduceBy);

      if (reduceBy > this.character.getStat(STATS.HIGHEST_DAMAGE_DONE)) {
        this.character.setStat(STATS.HIGHEST_DAMAGE_DONE, reduceBy);
      }
    }

    return originalHp - this._hp;
  }

  /**
   * Increase this combatant's HP by a certain amount.
   *
   * @param {integer} increaseBy The amount of HP to increase by.
   *
   * @return {integer} The difference in HP.
   */
  increaseHp(increaseBy) {
    // Whole integer, at least one
    increaseBy = Math.ceil(increaseBy);

    // Don't increase HP if your HP is already higher than your max (for temp HP)
    if (this._hp > this.maxHp) {
      return 0;
    }

    let originalHp = this._hp;
    this._hp = Math.min(this.maxHp, this._hp + increaseBy);

    return this._hp - originalHp;
  }

  /**
   * Perform any actions that happen before the round (guard, etc.)
   *
   * @return {array} Messages generated by these actions.
   */
  doPreRoundActions() {}

  /**
   * Perform any actions that happen after the round (decrement/clear all timers, etc)
   *
   * @param {Combatant} opponent - The current combatant's opponent.
   *
   * @return {array} Messages generated by these actions.
   */
  doPostRoundActions(opponent) {
    let messages = [];

    for (const status of ROUND_TIMED_STATUSES) {
      this.decrementFlag(status);
    }

    for (const status of SINGLE_TURN_STATUSES) {
      this.clearFlag(status);
    }

    if (this.hasFlag(FLAGS.BURNED_TURNS)) {
      const name = this.isCharacter() ? "You are" : `${this.getDisplayName(opponent)} ${this.isAre}`;
      const turns = this.getFlag(FLAGS.BURNED_TURNS);
      const turnsText = turns > 1 ? `${turns} turns` : "1 turn";
      messages.push(`:fire: ${name} burned for ${turnsText} and will take more damage from Burn attacks!`);
    }

    if (this.hasFlag(FLAGS.CHILLED_TURNS)) {
      const name = this.isCharacter() ? "You are" : `${this.getDisplayName(opponent)} ${this.isAre}`;
      const turns = this.getFlag(FLAGS.CHILLED_TURNS);
      const turnsText = turns > 1 ? `${turns} turns` : "1 turn";
      messages.push(`:snowflake: ${name} chilled for ${turnsText} and will have a harder time dodging!`);
    }

    if (this.hasFlag(FLAGS.POISONED_TURNS)) {
      const damage = this.getFlag(FLAGS.POISON_DAMAGE);
      this.decreaseHp(damage);
      const targetText = this.isCharacter() ? "your" : `${this.getDisplayName(opponent)}'s`;
      const remainingTurns = this.getFlag(FLAGS.POISONED_TURNS) - 1;
      const remainingText = remainingTurns > 0 ? ` (${remainingTurns} turns remaining)` : "";
      messages.push(`:face_vomiting: Poison burns in ${targetText} veins for ${damage} damage${remainingText}.`);
    }

    if (this.hasFlag(FLAGS.ENRAGED_TURNS)) {
      const remainingTurns = this.getFlag(FLAGS.ENRAGED_TURNS) - 1;
      const remainingText = remainingTurns > 0 ? ` (${remainingTurns} turns remaining)` : "";
      messages.push(`${this.getDisplayName(opponent)} is enraged and can only attack${remainingText}!`);
    }

    if (this.hasFlag(FLAGS.WINDWALL_TURNS)) {
      const remainingTurns = this.getFlag(FLAGS.WINDWALL_TURNS) - 1;
      const remainingText = remainingTurns > 0 ? ` (${remainingTurns} turns remaining)` : "";
      messages.push(`A wall of wind blows around you.${remainingText}`);
    }

    return messages;
  }

  /**
   * Identify if this combatant is a Character or an Enemy.
   *
   * @return {boolean}
   */
  isCharacter() {
    return _.get(this, 'email', false);
  }

  /**
   * Clear all multi-turn statuses, called usually at end of battle.
   */
  clearAllTimers() {
    for (let status of ROUND_TIMED_STATUSES) {
      this.clearFlag(status);
    }
  }

  /**
   * Determine if these two combatants are at range.
   *
   * @param {Combatant} opponent - The opponent of this combantant.
   *
   * @return {boolean}
   */
  isAtRange(opponent) {
    return opponent.hasFlag(FLAGS.IS_RANGED) || this.hasFlag(FLAGS.IS_RANGED);
  }

  /**
   * Effect attacks cannot miss, crit, or be dodged.
   *
   * @param {Combatant} defender - The combatant defending against this attack.
   * @param {array} attackProperties - The properties of the attack.
   *
   * @return {object}
   */
  getEffectAttackInfo(defender, attackProperties = []) {
    const originalCannotCrit  = this.getFlag(FLAGS.CANNOT_CRIT);
    const originalCannotMiss  = this.getFlag(FLAGS.CANNOT_MISS);
    const originalCannotDodge = this.getFlag(FLAGS.CANNOT_DODGE);

    this.setFlag(FLAGS.CANNOT_CRIT);
    this.setFlag(FLAGS.CANNOT_MISS);
    defender.setFlag(FLAGS.CANNOT_DODGE);

    const attackInfo = this.getAttackInfo(defender, attackProperties);

    this.clearFlag(FLAGS.CANNOT_CRIT, originalCannotCrit);
    this.clearFlag(FLAGS.CANNOT_MISS, originalCannotMiss);
    defender.clearFlag(FLAGS.CANNOT_DODGE, originalCannotDodge);

    return attackInfo;
  }

  /**
   * Are we are making a missable attack, but the defender is invisible?
   *
   * @param {Combatant} defender - The defender of the attack.
   *
   * @return {boolean}
   */
  isDefenderInvisible(defender) {
    return ! this.hasFlag(FLAGS.CANNOT_MISS) && defender.hasFlag(FLAGS.IS_INVISIBLE);
  }

  /**
   * Are we are blind?
   *
   * @return {boolean}
   */
  isAttackerBlind() {
    return this.hasFlag(FLAGS.BLIND_TURNS);
  }

  /**
   * Did the defender dodge the attack?
   *
   * @param {Combatant} defender - The defender of the attack.
   * @param {integer} dodge - The chance of dodging.
   *
   * @return {boolean}
   */
  didDefenderDodge(defender, dodge) {
    return ! defender.hasFlag(FLAGS.CANNOT_DODGE) && Random.between(1, 100) <= dodge;
  }

  /**
   * Are we blind from acid?
   *
   * @param {Combatant} defender - The defender of the attack.
   *
   * @return {boolean}
   */
  isAttackerAcidBlind(defender) {
    return ! this.hasFlag(FLAGS.CANNOT_MISS) && defender.hasFlag(FLAGS.ACID_TURNS) && Random.between(1, 100) <= ACID_BLIND_CHANCE;
  }

  /**
   * Are we clumsy from a Cursed Chest curse?
   *
   * @return {boolean}
   */
  isChestCurseClumsy() {
    return this.hasFlag(FLAGS.CHEST_CURSE_CLUMSY) && Random.between(1, 100) <= CURSED_CHEST_MISS_CHANCE;
  }

  /**
   * Did we critically hit?
   *
   * @param {Combatant} defender - The defender of the attack.
   * @param {integer} crit - The chance of critically hitting.
   *
   * @return {boolean}
   */
  didCriticalHit(defender, crit) {
    if ( ! this.hasFlag(FLAGS.CANNOT_CRIT)) {
      if (defender.hasFlag(FLAGS.IS_WEAKENED) || Random.between(1, 100) <= crit) {
        return true;
      }
    }

    return false;
  }

  /**
   * Do we have a damage modifier active?
   *
   * @return {boolean}
   */
  hasDamageModifier() {
    return this.hasFlag(FLAGS.DAMAGE_MODIFIER);
  }

  /**
   * Is the defender cursed?
   *
   * @param {Combatant} defender - The defender of the attack.
   *
   * @return {boolean}
   */
  isDefenderCursed(defender) {
    return defender.hasFlag(FLAGS.CURSED_TURNS);
  }

  /**
   * Get the results of an attack from this combatant to another.
   *
   * @param {Combatant} defender - The combatant defending against this attack.
   * @param {array} attackProperties - The properties of the attack.
   *
   * @return {object}
   */
  getAttackInfo(defender, attackProperties = []) {
    let attackInfo = {
      damage: 0,
      didCrit: false,
      didDodge: false,
      didMiss: false,
      extraMessages: [],
    };

    const {
      weaponDamage,
      offence,
      multiplier,
      crit,
      defence,
      dodge,
      paramExtraMessages
    } = this.getAttackParameters(defender, attackProperties);

    attackInfo.extraMessages = paramExtraMessages;

    if (this.isDefenderInvisible(defender)) {
      attackInfo.didMiss = true;
      attackInfo.damage = 0;
    }

    else if (this.isAttackerBlind()) {
      attackInfo.didMiss = true;
      attackInfo.damage = 0;
    }

    else if (this.didDefenderDodge(defender, dodge)) {
      attackInfo.didDodge = true;
      attackInfo.damage = 0;
    }

    else if (this.isAttackerAcidBlind(defender)) {
      attackInfo.didMiss = true;
      attackInfo.damage = 0;
      attackInfo.extraMessages.push("The acid in your eyes causes you to flail wildly and miss!");
    }

    else if (this.isChestCurseClumsy()) {
      attackInfo.didMiss = true;
      attackInfo.damage = 0;
      attackInfo.extraMessages.push("You fumble around, nearly dropping your weapon.");
    }

    // If, after all that, we're still attacking
    else {
      const da = this.getDamageAbsorption(offence, defence);

      attackInfo.damage = Math.max(1, Math.ceil(weaponDamage * da * multiplier));

      if (this.didCriticalHit(defender, crit)) {
        defender.clearFlag(FLAGS.IS_WEAKENED);
        attackInfo.didCrit = true;
        attackInfo.damage = Math.max(2, Math.ceil(attackInfo.damage * this.getCritBonus(defender)));
      }

      if (this.hasDamageModifier()) {
        attackInfo.damage = Math.ceil(attackInfo.damage * this.getFlag(FLAGS.DAMAGE_MODIFIER));
      }

      if (this.isDefenderCursed(defender)) {
        attackInfo.damage = Math.ceil(attackInfo.damage * 1.5);
      }

      for (const property of attackProperties) {
        attackInfo = this.checkProperty(property, defender, attackInfo);
      }
    }

    attackInfo = this.doAttackerPostAttackProcessing(attackInfo, defender);
    attackInfo = defender.doDefenderPostAttackProcessing(attackInfo, this);

    return attackInfo;
  }

  /**
   * Check an attack property and see if it has an effect against this defender.
   *
   * @param {string} property - The property to check.
   * @param {Combatant} defender - The defender against this attack.
   * @param {object} attackInfo - The attackInfo to modify and return.
   *
   * @return {object}
   */
  checkProperty(property, defender, attackInfo) {
    // AoE attack against group enemies do 1.5x damage
    if (property === PROPERTIES.AOE_ATTACK && defender.properties.includes(PROPERTIES.IS_GROUP)) {
      attackInfo.damage = Math.ceil(attackInfo.damage * AOE_BONUS);
      attackInfo.extraMessages.push(`${defender.getDisplayName(this)} takes extra damage from your AoE attack!`);
    }
    // Burn attacks apply Burned and do bonus damage against burned opponents
    else if (property === PROPERTIES.BURN_ATTACK) {
      if (defender.hasFlag(FLAGS.BURNED_TURNS)) {
        attackInfo.damage = Math.ceil(attackInfo.damage * BURN_BONUS);
        attackInfo.extraMessages.push(`:fire: ${defender.getDisplayName(this)} ${defender.isAre} burned and ${defender.isAre === "is" ? "takes" : "take"} extra damage from the burn attack!`);
      }

      attackInfo.extraMessages = attackInfo.extraMessages.concat(defender.addStatusBurned());
    }
    // Chill attacks reduce dodge
    else if (property === PROPERTIES.CHILL_ATTACK) {
      attackInfo.extraMessages = attackInfo.extraMessages.concat(defender.addStatusChilled());
    }

    return attackInfo;
  }

  /**
   * Get the amount of damage absorbed by a defending character.
   *
   * @param {integer} offence - The offence stat of the attacking character.
   * @param {integer} defence - The defence stat of the defending character.
   *
   * @return {float}
   */
  getDamageAbsorption(offence, defence) {
    return (10 + offence) / (10 + defence);
  }

  /**
   * Get the attack parameters this combatant for a combat round.
   *
   * @param {Combatant} defender - The defending combatant.
   * @param {array} attackProperties - The properties of the attack.
   *
   * @return {object}
   */
  getAttackParameters(defender, attackProperties) {
    let params = {
      weaponDamage: Random.between(this.minDamage, this.maxDamage),
      offence: this.getOffence(),
      multiplier: 1 + (this.level / 20),
      crit: this.crit,
      defence: defender.defence,
      dodge: defender.dodge,
      paramExtraMessages: [],
    };

    if (this.hasFlag(FLAGS.IS_IGNORING_QUARTER_ARMOUR)) {
      params.defence = Math.ceil(params.defence * 0.75);
    }
    else if (this.hasFlag(FLAGS.IS_IGNORING_HALF_ARMOUR)) {
      params.defence = Math.ceil(params.defence * 0.50);
    }

    if (this.hasFlag(FLAGS.GUARANTEED_HIT_TURNS)) {
      params.dodge = 0;
    }

    if (this.hasFlag(FLAGS.DISORIENTED_TURNS)) {
      params.dodge = Math.max(params.dodge, 50);
    }

    if (defender.hasFlag(FLAGS.MIST_BALM_TURNS)) {
      params.dodge = Math.min(100, params.dodge + 25);
    }

    if (defender.hasFlag(FLAGS.CHILLED_TURNS)) {
      params.dodge = Math.max(params.dodge - CHILL_REDUCTION, 0);
    }

    if (defender.hasFlag(FLAGS.IS_EVADING)) {
      params.dodge = Math.min(params.dodge + 25, 100);
    }

    // Cannot dodge if stunned
    if (defender.hasFlag(FLAGS.STUNNED_TURNS)) {
      params.dodge = 0;
    }

    if (this.hasFlag(FLAGS.IS_MISDIRECTING)) {
      params.crit = 100;
    }
    else if (this.hasFlag(FLAGS.IS_DISCIPLINED)) {
      params.crit = 0;
    }

    // If attacking after defending with hidden daggers
    if (this.hasFlag(FLAGS.HAS_DAGGERS_HIDDEN) && attackProperties.includes(PROPERTIES.IS_ATTACK)) {
      params.crit = Math.min(params.crit + HIDDEN_DAGGERS_CRIT_BONUS, 100);
      this.clearFlag(FLAGS.HAS_DAGGERS_HIDDEN);
      params.paramExtraMessages.push("With your daggers now visible, you lose your crit chance bonus.");
    }

    // Enfeeble lowers offence on attack and defence on defence
    if (defender.hasFlag(FLAGS.FEEBLE_TURNS)) {
      const spell = Spells.new("enfeeble");
      const enfeebledBy = spell.getEnfeebleAmount(this);
      const modifier = (100 - enfeebledBy) / 100;

      params.defence = Math.ceil(params.defence * modifier);
    }
    if (this.hasFlag(FLAGS.FEEBLE_TURNS)) {
      const spell = Spells.new("enfeeble");
      const enfeebledBy = spell.getEnfeebleAmount(defender);
      const modifier = (100 - enfeebledBy) / 100;

      params.offence = Math.ceil(params.offence * modifier);
    }

    // Dazed lowers defence by 25%
    if (defender.hasFlag(FLAGS.DAZED_TURNS)) {
      params.defence = Math.ceil(params.defence * 0.75);
    }

    params = this.attackerModifyAttackParameters(params, defender);
    params = defender.defenderModifyAttackParameters(params, this);

    return params;
  }

  /**
   * Allow attack parameters to be modified before being used in an attack.
   *
   * @param {object} params - The parameters to modify.
   * @param {Combatant} defender - The defender of the attack.
   *
   * @return {object}
   */
  attackerModifyAttackParameters(params, defender) {
    return params;
  }

  /**
   * Allow attack parameters to be modified before being used in an attack.
   *
   * @param {object} params - The parameters to modify.
   * @param {Combatant} attacker - The attacker.
   *
   * @return {object}
   */
  defenderModifyAttackParameters(params, attacker) {
    return params;
  }

  /**
   * Get the offence stat for this combatant.  (Force by default, to make enmies easy to balance.)
   *
   * @return {integer}
   */
  getOffence() {
    return this.force;
  }

  /**
   * If the distance between combatants can be closed at this time.
   *
   * @param {Combatant} opponent - The opposing combatant.
   *
   * @return {boolean}
   */
  canCloseDistance(opponent) {
    return true;
  }

  /**
   * The message returned when failing to close distance.
   *
   * @param {Combatant} opponent - The opposing combatant.
   *
   * @return {string}
   */
  getCloseDistanceFailureMessage(opponent) {
    return "";
  }

  // -- Flags -----------------------------------------------------------------------------------

  /**
   * Increment the value of a flag.
   *
   * @param {string} flag - The flag to increment.
   * @param {integer} by - The amount to increment by.
   * @param {integer} defaultValue - The default value to start a flag with.
   *
   */
  incrementFlag(flag, by = 1, defaultValue = 0) {
    this._flags[flag] = this.getFlag(flag, defaultValue) + by;
  }

  /**
   * Decrement the number of turns a flag is active for.
   *
   * @param {string} flag - The flag to decrease turns for.
   * @param {integer} by - The amount to decrement by.
   * @param {integer} defaultValue - The default value to start a flag with.
   */
  decrementFlag(flag, by = 1, defaultValue = 0) {
    const value = this.getFlag(flag, defaultValue) - by;

    if (value > 0) {
      this._flags[flag] = value;
    }
    else {
      this.clearFlag(flag);
    }
  }

  /**
   * Set a flag for this character.
   *
   * @param {string} flag - The flag to set.
   * @param {mixed} value - The value to set (default true).
   *
   * @return {void}
   */
  setFlag(flag, value = true) {
    this._flags[flag] = value;
  }

  /**
   * Get the value of a flag.
   *
   * @param {string} flag - The flag to get the value of.
   * @param {mixed} defaultValue - The value to default to, if character does not have this flag set.
   */
  getFlag(flag, defaultValue = 0) {
    return _.get(this._flags, flag, defaultValue);
  }

  /**
   * Get all flags, used for saving.
   */
  getFlags() {
    return this._flags;
  }

  /**
   * Check and see if a character has a flag set.
   *
   * @param {string} flag - The flag to check.
   * @param {mixed} value - If set, make sure the flag is equal to this value.
   *
   * @return {boolean}
   */
  hasFlag(flag, value) {
    if (_.isDefined(value)) {
      return this._flags[flag] === value;
    }

    if (_.isDefined(this._flags[flag])) {
      return Boolean(this._flags[flag]);
    }

    return false;
  }

  /**
   * Clear a flag.
   *
   * @param {string} flag - The flag to clear.
   */
  clearFlag(flag) {
    delete this._flags[flag];
  }

  // -- /Flags ----------------------------------------------------------------------------------

  // -- Stat placeholders to allow for testing --------------------------------------------------

  increaseStat() {}
  getStat() {}

  // -- /Stat placeholders ----------------------------------------------------------------------

  // -- Status effects --------------------------------------------------------------------------

  /**
   * Adds the "Burned" status to this combatant.
   *
   * @param {integer} turns - The # of turns this combatant will be burned for.
   *
   * @return [string] - Any messages generated by adding this status.
   */
  addStatusBurned(turns = null) {
    if (this.hasFlag(FLAGS.COLD_COMPRESS_TURNS)) {
      return [`:snowflake: ${this.isCharacter() ? 'Your' : `${this.getDisplayName()}'s`} cold compress prevents the burn!`];
    }

    // Flag is immediately decremented by one on first turn, so add 1 for "actual" # of turns
    this.setFlag(FLAGS.BURNED_TURNS, (turns || DEFAULT_BURNED_TURNS) + 1);

    return [];
  }

  /**
   * Adds the "Chilled" status to this combatant.
   *
   * @param {integer} turns - The # of turns this combatant will be chilled for.
   *
   * @return [string] - Any messages generated by adding this status.
   */
  addStatusChilled(turns = null) {
    if (this.hasFlag(FLAGS.HOT_CHOCOLATE_TURNS)) {
      return [`:coffee: ${this.isCharacter() ? 'Your' : `${this.getDisplayName()}'s`} hot chocolate prevents the chill!`];
    }

    // Flag is immediately decremented by one on first turn, so add 1 for "actual" # of turns
    this.setFlag(FLAGS.CHILLED_TURNS, (turns || DEFAULT_CHILLED_TURNS) + 1);

    return [];
  }

  // -- /Status effects -------------------------------------------------------------------------
}

module.exports = Combatant;